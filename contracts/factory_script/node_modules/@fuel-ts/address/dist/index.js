"use strict";var u=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var K=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var k=(r,o)=>{for(var t in o)u(r,t,{get:o[t],enumerable:!0})},C=(r,o,t,f)=>{if(o&&typeof o=="object"||typeof o=="function")for(let c of K(o))!R.call(r,c)&&c!==t&&u(r,c,{get:()=>o[c],enumerable:!(f=v(o,c))||f.enumerable});return r};var O=r=>C(u({},"__esModule",{value:!0}),r);var W={};k(W,{Address:()=>e,FUEL_BECH32_HRP_PREFIX:()=>d,addressify:()=>H,fromBech32:()=>m,getBytesFromBech32:()=>B,getRandomB256:()=>b,isB256:()=>p,isBech32:()=>i,isPublicKey:()=>a,normalizeBech32:()=>l,toB256:()=>g,toBech32:()=>A});module.exports=O(W);var n=require("@ethersproject/bytes"),x=require("@ethersproject/logger"),h=require("@fuel-ts/interfaces"),w=require("@fuel-ts/keystore"),S=require("@fuel-ts/versions"),s=require("bech32"),D=new x.Logger(S.versions.FUELS),d="fuel";function m(r){return s.bech32m.decode(r)}function A(r){return s.bech32m.encode(d,s.bech32m.toWords((0,n.arrayify)((0,n.hexlify)(r))))}function i(r){return typeof r=="string"&&r.indexOf(d+1)===0&&m(r).prefix===d}function p(r){return(r.length===66||r.length===64)&&/(0x)?[0-9a-f]{64}$/i.test(r)}function a(r){return(r.length===130||r.length===128)&&/(0x)?[0-9a-f]{128}$/i.test(r)}function B(r){return new Uint8Array(s.bech32m.fromWords(m(r).words))}function g(r){return i(r)||D.throwArgumentError("Invalid Bech32 Address","address",r),(0,n.hexlify)(B(r))}function l(r){let{words:o}=m(r);return s.bech32m.encode(d,o)}var H=r=>r instanceof h.AbstractWallet?r.address:r instanceof h.AbstractContract?r.id:r,b=()=>(0,n.hexlify)((0,w.randomBytes)(32));var L=require("@ethersproject/logger"),P=require("@ethersproject/sha2"),U=require("@fuel-ts/interfaces"),F=require("@fuel-ts/versions");var E=new L.Logger(F.versions.FUELS),e=class extends U.AbstractAddress{constructor(t){super();E.checkNew(new.target,e),this.bech32Address=l(t),i(this.bech32Address)||E.throwArgumentError("Invalid Bech32 Address","address",t)}toAddress(){return this.bech32Address}toB256(){return g(this.bech32Address)}toBytes(){return B(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(t){return this.bech32Address===t.bech32Address}static fromPublicKey(t){let f=(0,P.sha256)(t);return new e(A(f))}static fromB256(t){return new e(A(t))}static fromRandom(){return this.fromB256(b())}static fromString(t){return i(t)?new e(t):this.fromB256(t)}static fromAddressOrString(t){return typeof t=="string"?this.fromString(t):t}static fromDynamicInput(t){if(a(t))return e.fromPublicKey(t);if(i(t))return new e(t);if(p(t))return e.fromB256(t);throw new Error("Unknown address format: only Bech32, B256, or Public Key (512) supported")}};0&&(module.exports={Address,FUEL_BECH32_HRP_PREFIX,addressify,fromBech32,getBytesFromBech32,getRandomB256,isB256,isBech32,isPublicKey,normalizeBech32,toB256,toBech32});
//# sourceMappingURL=index.js.map