type Bech32Address = `fuel${string}`;
type B256Address = string;
declare abstract class AbstractScript<T> {
    abstract bytes: Uint8Array;
    abstract encodeScriptData: (data: T) => Uint8Array;
}
declare abstract class AbstractAddress {
    abstract toJSON(): string;
    abstract toString(): string;
    abstract toAddress(): Bech32Address;
    abstract toB256(): B256Address;
    abstract toHexString(): string;
    abstract toBytes(): Uint8Array;
    abstract equals(other: AbstractAddress): boolean;
}
declare abstract class AbstractContract {
    abstract id: AbstractAddress;
}
declare abstract class AbstractWallet {
    abstract address: AbstractAddress;
}
type AddressLike = AbstractAddress | AbstractWallet;
type ContractIdLike = AbstractAddress | AbstractContract;
declare abstract class AbstractPredicate {
    abstract bytes: Uint8Array;
    abstract address: AbstractAddress;
    abstract types?: ReadonlyArray<any>;
}

export { AbstractAddress, AbstractContract, AbstractPredicate, AbstractScript, AbstractWallet, AddressLike, B256Address, Bech32Address, ContractIdLike };
