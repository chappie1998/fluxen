import{arrayify as y,hexlify as i}from"@ethersproject/bytes";import{Logger as x}from"@ethersproject/logger";import{AbstractContract as w,AbstractWallet as S}from"@fuel-ts/interfaces";import{randomBytes as E}from"@fuel-ts/keystore";import{versions as L}from"@fuel-ts/versions";import{bech32m as o}from"bech32";var P=new x(L.FUELS),n="fuel";function c(r){return o.decode(r)}function d(r){return o.encode(n,o.toWords(y(i(r))))}function s(r){return typeof r=="string"&&r.indexOf(n+1)===0&&c(r).prefix===n}function B(r){return(r.length===66||r.length===64)&&/(0x)?[0-9a-f]{64}$/i.test(r)}function u(r){return(r.length===130||r.length===128)&&/(0x)?[0-9a-f]{128}$/i.test(r)}function f(r){return new Uint8Array(o.fromWords(c(r).words))}function p(r){return s(r)||P.throwArgumentError("Invalid Bech32 Address","address",r),i(f(r))}function a(r){let{words:h}=c(r);return o.encode(n,h)}var W=r=>r instanceof S?r.address:r instanceof w?r.id:r,g=()=>i(E(32));import{Logger as U}from"@ethersproject/logger";import{sha256 as F}from"@ethersproject/sha2";import{AbstractAddress as v}from"@fuel-ts/interfaces";import{versions as K}from"@fuel-ts/versions";var l=new U(K.FUELS),e=class extends v{constructor(t){super();l.checkNew(new.target,e),this.bech32Address=a(t),s(this.bech32Address)||l.throwArgumentError("Invalid Bech32 Address","address",t)}toAddress(){return this.bech32Address}toB256(){return p(this.bech32Address)}toBytes(){return f(this.bech32Address)}toHexString(){return this.toB256()}toString(){return this.bech32Address}toJSON(){return this.toString()}valueOf(){return this.toString()}equals(t){return this.bech32Address===t.bech32Address}static fromPublicKey(t){let b=F(t);return new e(d(b))}static fromB256(t){return new e(d(t))}static fromRandom(){return this.fromB256(g())}static fromString(t){return s(t)?new e(t):this.fromB256(t)}static fromAddressOrString(t){return typeof t=="string"?this.fromString(t):t}static fromDynamicInput(t){if(u(t))return e.fromPublicKey(t);if(s(t))return new e(t);if(B(t))return e.fromB256(t);throw new Error("Unknown address format: only Bech32, B256, or Public Key (512) supported")}};export{e as Address,n as FUEL_BECH32_HRP_PREFIX,W as addressify,c as fromBech32,f as getBytesFromBech32,g as getRandomB256,B as isB256,s as isBech32,u as isPublicKey,a as normalizeBech32,p as toB256,d as toBech32};
//# sourceMappingURL=index.mjs.map