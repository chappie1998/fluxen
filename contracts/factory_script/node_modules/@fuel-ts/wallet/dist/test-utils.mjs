var B=(n=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(n,{get:(s,e)=>(typeof require!="undefined"?require:s)[e]}):n)(function(n){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+n+'" is not supported')});var _=(n,s)=>()=>(n&&(s=n(n=0)),s);var i=_(()=>{});i();i();i();i();var l="http://127.0.0.1:4000/graphql";i();import{HDWallet as C}from"@fuel-ts/hdwallet";import{Mnemonic as X}from"@fuel-ts/mnemonic";import{Signer as W}from"@fuel-ts/signer";i();import{arrayify as L,hexlify as z}from"@ethersproject/bytes";import{Address as Q,addressify as D}from"@fuel-ts/address";import{NativeAssetId as T}from"@fuel-ts/constants";import{AbstractWallet as V}from"@fuel-ts/interfaces";import{bn as G}from"@fuel-ts/math";import{withdrawScript as I,ScriptTransactionRequest as k,Provider as H,transactionRequestify as K}from"@fuel-ts/providers";import{MAX_GAS_PER_TX as A}from"@fuel-ts/transactions";var g=class extends V{constructor(e,t=l){super();this.provider=this.connect(t),typeof e=="string"?this._address=Q.fromString(e):this._address=D(e)}get address(){return this._address}connect(e){if(e)typeof e=="string"?this.provider?this.provider.connect(e):this.provider=new H(e):this.provider=e;else throw new Error("Provider is required");return this.provider}async getResourcesToSpend(e,t){return this.provider.getResourcesToSpend(this.address,e,t)}async getCoins(e){let t=[],o;for(;;){let a=await this.provider.getCoins(this.address,e,{first:9999,after:o});if(t.push(...a),!(a.length>=9999))break;throw new Error(`Wallets with more than ${9999} coins are not yet supported`)}return t}async getMessages(){let e=[],r;for(;;){let o=await this.provider.getMessages(this.address,{first:9999,after:r});if(e.push(...o),!(o.length>=9999))break;throw new Error(`Wallets with more than ${9999} messages are not yet supported`)}return e}async getBalance(e=T){return await this.provider.getBalance(this.address,e)}async getBalances(){let e=[],r;for(;;){let o=await this.provider.getBalances(this.address,{first:9999,after:r});if(e.push(...o),!(o.length>=9999))break;throw new Error(`Wallets with more than ${9999} balances are not yet supported`)}return e}async fund(e){let t=e.calculateFee(),r=await this.getResourcesToSpend([t]);e.addResources(r)}async transfer(e,t,r=T,o={}){let a={gasLimit:A,...o},d=new k(a);d.addCoinOutput(e,t,r);let m=d.calculateFee(),f=[];m.assetId===z(r)?(m.amount=m.amount.add(t),f=[m]):f=[[t,r],m];let h=await this.getResourcesToSpend(f);return d.addResources(h),this.sendTransaction(d)}async withdrawToBaseLayer(e,t,r={}){let o=L("0x".concat(e.toHexString().substring(2).padStart(64,"0"))),a=L("0x".concat(G(t).toHex().substring(2).padStart(16,"0"))),m={script:new Uint8Array([...L(I.bytes),...o,...a]),gasLimit:A,...r},f=new k(m);f.addMessageOutputs();let h=f.calculateFee(),q=[];h.amount=h.amount.add(t),q=[h];let O=await this.getResourcesToSpend(q);return f.addResources(O),this.sendTransaction(f)}async sendTransaction(e){let t=K(e);return await this.provider.addMissingVariables(t),this.provider.sendTransaction(t)}async simulateTransaction(e){let t=K(e);return await this.provider.addMissingVariables(t),this.provider.simulate(t)}async buildPredicateTransaction(e,t,r=T,o){let a={fundTransaction:!0,...o},d=new k({gasLimit:A,...a});d.addCoinOutput(e,t,r);let m=[];if(a.fundTransaction&&m.push(d.calculateFee()),m.length){let f=await this.getResourcesToSpend(m);d.addResources(f)}return d}async submitPredicate(e,t,r=T,o){let a=await this.buildPredicateTransaction(e,t,r,o);return(await this.sendTransaction(a)).waitForResult()}async submitSpendPredicate(e,t,r,o=T,a){return this.provider.submitSpendPredicate(e,t,this.address,r,o,a)}};i();import{hashMessage as j,hashTransaction as J}from"@fuel-ts/hasher";import{transactionRequestify as R}from"@fuel-ts/providers";import{Signer as $}from"@fuel-ts/signer";var v=class extends g{constructor(e,t=l){let r=new $(e);super(r.address,t);this.signer=()=>r,this.provider=this.connect(t)}get privateKey(){return this.signer().privateKey}get publicKey(){return this.signer().publicKey}async signMessage(e){return this.signer().sign(j(e))}async signTransaction(e){let t=R(e),r=J(t);return this.signer().sign(r)}async populateTransactionWitnessesSignature(e){let t=R(e),r=await this.signTransaction(t);return t.updateWitnessByOwner(this.address,r),t}async sendTransaction(e){let t=R(e);return await this.provider.addMissingVariables(t),this.provider.sendTransaction(await this.populateTransactionWitnessesSignature(t))}async simulateTransaction(e){let t=R(e);return await this.provider.addMissingVariables(t),this.provider.call(await this.populateTransactionWitnessesSignature(t),{utxoValidation:!0})}};v.defaultPath="m/44'/1179993420'/0'/0/0";var w=class extends g{unlock(s){return new c(s,this.provider)}},c=class extends v{lock(){return this.signer=()=>new W("0x00"),new w(this.address,this.provider)}static generate(s){let e=W.generatePrivateKey(s==null?void 0:s.entropy);return new c(e,s==null?void 0:s.provider)}static fromSeed(s,e,t){let o=C.fromSeed(s).derivePath(e||c.defaultPath);return new c(o.privateKey,t)}static fromMnemonic(s,e,t,r){let o=X.mnemonicToSeed(s,t),d=C.fromSeed(o).derivePath(e||c.defaultPath);return new c(d.privateKey,r)}static fromExtendedKey(s,e){let t=C.fromExtendedKey(s);return new c(t.privateKey,e)}};var y=class{static fromAddress(s,e=l){return new w(s,e)}static fromPrivateKey(s,e=l){return new c(s,e)}};y.generate=c.generate,y.fromSeed=c.fromSeed,y.fromMnemonic=c.fromMnemonic,y.fromExtendedKey=c.fromExtendedKey;i();i();i();i();i();import{arrayify as Ae}from"@ethersproject/bytes";i();var S,N="Node";typeof globalThis<"u"&&globalThis.crypto&&(S=globalThis.crypto,N="Web");if(!S&&typeof B=="function")try{S=B("crypto"),N="Node"}catch(n){console.error("keystore expects a standard Web browser or Node environment.",n)}var P=S,x=N;i();var b=n=>x==="Node"?P.randomBytes(n):P.getRandomValues(new Uint8Array(n));i();import{coinQuantityfy as Y,ScriptTransactionRequest as Z}from"@fuel-ts/providers";var M=async(n,s)=>{let e=new c(process.env.GENESIS_SECRET||b(32),n.provider),t=await e.getResourcesToSpend(s),r=new Z({gasLimit:1e4,gasPrice:1});r.addResources(t),s.map(Y).forEach(({amount:a,assetId:d})=>r.addCoinOutput(n.address,a,d)),await(await e.sendTransaction(r)).wait()};var nt=async(n,s)=>{let e=y.generate({provider:n});return s&&await M(e,s),e};export{nt as generateTestWallet,M as seedTestWallet};
//# sourceMappingURL=test-utils.mjs.map