import{arrayify as v,hexlify as A}from"@ethersproject/bytes";import{Address as q,addressify as C}from"@fuel-ts/address";import{NativeAssetId as f}from"@fuel-ts/constants";import{AbstractWallet as E}from"@fuel-ts/interfaces";import{bn as N}from"@fuel-ts/math";import{withdrawScript as M,ScriptTransactionRequest as w,Provider as K,transactionRequestify as k}from"@fuel-ts/providers";import{MAX_GAS_PER_TX as L}from"@fuel-ts/transactions";var u="http://127.0.0.1:4000/graphql";var p=class extends E{constructor(e,t=u){super();this.provider=this.connect(t),typeof e=="string"?this._address=q.fromString(e):this._address=C(e)}get address(){return this._address}connect(e){if(e)typeof e=="string"?this.provider?this.provider.connect(e):this.provider=new K(e):this.provider=e;else throw new Error("Provider is required");return this.provider}async getResourcesToSpend(e,t){return this.provider.getResourcesToSpend(this.address,e,t)}async getCoins(e){let t=[],r;for(;;){let a=await this.provider.getCoins(this.address,e,{first:9999,after:r});if(t.push(...a),!(a.length>=9999))break;throw new Error(`Wallets with more than ${9999} coins are not yet supported`)}return t}async getMessages(){let e=[],s;for(;;){let r=await this.provider.getMessages(this.address,{first:9999,after:s});if(e.push(...r),!(r.length>=9999))break;throw new Error(`Wallets with more than ${9999} messages are not yet supported`)}return e}async getBalance(e=f){return await this.provider.getBalance(this.address,e)}async getBalances(){let e=[],s;for(;;){let r=await this.provider.getBalances(this.address,{first:9999,after:s});if(e.push(...r),!(r.length>=9999))break;throw new Error(`Wallets with more than ${9999} balances are not yet supported`)}return e}async fund(e){let t=e.calculateFee(),s=await this.getResourcesToSpend([t]);e.addResources(s)}async transfer(e,t,s=f,r={}){let a={gasLimit:L,...r},o=new w(a);o.addCoinOutput(e,t,s);let c=o.calculateFee(),d=[];c.assetId===A(s)?(c.amount=c.amount.add(t),d=[c]):d=[[t,s],c];let g=await this.getResourcesToSpend(d);return o.addResources(g),this.sendTransaction(o)}async withdrawToBaseLayer(e,t,s={}){let r=v("0x".concat(e.toHexString().substring(2).padStart(64,"0"))),a=v("0x".concat(N(t).toHex().substring(2).padStart(16,"0"))),c={script:new Uint8Array([...v(M.bytes),...r,...a]),gasLimit:L,...s},d=new w(c);d.addMessageOutputs();let g=d.calculateFee(),S=[];g.amount=g.amount.add(t),S=[g];let B=await this.getResourcesToSpend(S);return d.addResources(B),this.sendTransaction(d)}async sendTransaction(e){let t=k(e);return await this.provider.addMissingVariables(t),this.provider.sendTransaction(t)}async simulateTransaction(e){let t=k(e);return await this.provider.addMissingVariables(t),this.provider.simulate(t)}async buildPredicateTransaction(e,t,s=f,r){let a={fundTransaction:!0,...r},o=new w({gasLimit:L,...a});o.addCoinOutput(e,t,s);let c=[];if(a.fundTransaction&&c.push(o.calculateFee()),c.length){let d=await this.getResourcesToSpend(c);o.addResources(d)}return o}async submitPredicate(e,t,s=f,r){let a=await this.buildPredicateTransaction(e,t,s,r);return(await this.sendTransaction(a)).waitForResult()}async submitSpendPredicate(e,t,s,r=f,a){return this.provider.submitSpendPredicate(e,t,this.address,s,r,a)}};import{hashMessage as W,hashTransaction as z}from"@fuel-ts/hasher";import{transactionRequestify as R}from"@fuel-ts/providers";import{Signer as F}from"@fuel-ts/signer";var y=class extends p{constructor(e,t=u){let s=new F(e);super(s.address,t);this.signer=()=>s,this.provider=this.connect(t)}get privateKey(){return this.signer().privateKey}get publicKey(){return this.signer().publicKey}async signMessage(e){return this.signer().sign(W(e))}async signTransaction(e){let t=R(e),s=z(t);return this.signer().sign(s)}async populateTransactionWitnessesSignature(e){let t=R(e),s=await this.signTransaction(t);return t.updateWitnessByOwner(this.address,s),t}async sendTransaction(e){let t=R(e);return await this.provider.addMissingVariables(t),this.provider.sendTransaction(await this.populateTransactionWitnessesSignature(t))}async simulateTransaction(e){let t=R(e);return await this.provider.addMissingVariables(t),this.provider.call(await this.populateTransactionWitnessesSignature(t),{utxoValidation:!0})}};y.defaultPath="m/44'/1179993420'/0'/0/0";import{HDWallet as b}from"@fuel-ts/hdwallet";import{Mnemonic as _}from"@fuel-ts/mnemonic";import{Signer as x}from"@fuel-ts/signer";var P=class extends p{unlock(i){return new n(i,this.provider)}},n=class extends y{lock(){return this.signer=()=>new x("0x00"),new P(this.address,this.provider)}static generate(i){let e=x.generatePrivateKey(i==null?void 0:i.entropy);return new n(e,i==null?void 0:i.provider)}static fromSeed(i,e,t){let r=b.fromSeed(i).derivePath(e||n.defaultPath);return new n(r.privateKey,t)}static fromMnemonic(i,e,t,s){let r=_.mnemonicToSeed(i,t),o=b.fromSeed(r).derivePath(e||n.defaultPath);return new n(o.privateKey,s)}static fromExtendedKey(i,e){let t=b.fromExtendedKey(i);return new n(t.privateKey,e)}};var m=class{static fromAddress(i,e=u){return new P(i,e)}static fromPrivateKey(i,e=u){return new n(i,e)}};m.generate=n.generate,m.fromSeed=n.fromSeed,m.fromMnemonic=n.fromMnemonic,m.fromExtendedKey=n.fromExtendedKey;export{p as BaseWalletLocked,y as BaseWalletUnlocked,m as Wallet,P as WalletLocked,n as WalletUnlocked};
//# sourceMappingURL=index.mjs.map